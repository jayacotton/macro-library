;  work a bit like unix.  
;
;  find . -name string (print assumed)      Search the current drive 
;          ^^^^  full or partial name string.
;
;  find .  Prints all the file names on the current drive.
;
;  find * -name string     Search all the drives for the file name 
;  
#include "../../wto.mac"
#include "../../fflush.mac"
#include "../../pre.mac"
#include "../../post.mac"
#include "../../prestack.mac"
#include "../../cpmcommon.mac"
#include "../../fcb.mac"
#include "../../fileopen.mac"
#include "../../fileseek.mac"
#include "../../fread.mac"
#include "../../fileclose.mac"
#include "../../fmerr.mac"
#include "../../packfd.mac"
#include "../../memset.mac"
#include "../../strcpy.mac"
#include "../../setdma.mac"
#include "../../printl.mac"
#include "../../puts.mac"
#include "../../putc.mac"
#include "../../display.mac"
#include "../../startp.mac"
#include "../../radix.mac"
#include "../../mod.mac"
#include "../../comp.mac"
#include "../../divide.mac"
#include "../../multip.mac"
#include "../../binascii.mac"
#include "../../snap.mac"
#include "../../crlf.mac"
#include "../../printerrno.mac"
#include "../../strlen.mac"
#include "../../strchar.mac"
#include "../../getopt.mac"
#include "../../fputc.mac"
#include "../../filecreat.mac"

TRACE	equ	1
	common
	org	100h
	pre
	startp	front,list,count
;
; handle start paramets
;
	packfd	fifcb,'????????.???'
	lda	count
	ora	a
	jm	skip
;
; use get opt to process option flags 
; and setup the wild card file name and
; wild card drive names.....
; also handle all the listing options
;
startlp	getopt	count,list,'N:L:D'
	cpi	'L'	; list to a file
	jz	listf
	cpi	'N'	; find a name
	jz	namef
	cpi	'D'	; look only on this drive
	jz	drivf
	cpi	'.'	; 
	jz	dotf
	cpi	-1	; errors
	jz	skip
	cpi	0	; option not found
	jz	usage
	jmp	startlp	; go to next option
usage	wto	'-n[filename] -d[drive] -l[listfilename]'
	jmp	done	
dotf	equ	$
	mvi	a,1
	sta	flagdot
	jmp	startlp
listf	equ	$
	mvi	a,1
	sta	flagl
; hl -> list file name
	lxi	d,lifcb
	call	packfn
	create	lifcb
	open	lifcb
	memset	libuf,01ah,128
	if	TRACE
	wto	'list file'
; trace code
	lxi	h,lifcb
	call	trace
	endif
;  make a file name to dump the list on
	jmp	startlp
namef	equ	$
	mvi	a,1
	sta	flagn	
; hl -> file name
	lxi	d,fifcb
	call	packfn
;	snap	fifcb,22
	if	TRACE
	wto	'file name'
	lxi	h,fifcb
	call	trace
	endif
	jmp	startlp
drivf	equ	$
	mvi	a,1
	sta	flagd
; hl -> drive letter
	mov	a,m
	sbi	'A'
	sta	drivlet	
	if	TRACE
	wto	'drive letter'
	endif
	jmp	startlp
;
; process drive select 
;
skip	mvi	a,0	; preset drive to a:
	sta	curdriv
; see if the special case '.' was entered
	lda	flagd
	cpi	0
	jz	sknext
;fixme need to resolve the drive number here
	lda	drivlet	; get requested drive
	sta	curdriv
sknext	equ	$
;	snap	filenm,3
;	snap	fifcb,22
;
; figure out how many drives are mounted
;
;
scanlp	equ	$
;
; select drive
;
	lxi	h,fifcb
	lda	curdriv
	mov	m,a
	mvi	c,0eh
	mov	e,a
	call	bdos
	call	dorest
	call	nxtdriv
;
; test for end of drive list
;
; if the drive search was a . search then all or a drive letter then we only
; search one drive, else all of them.
;
	lda	flagdot
	ora	a
	jnz	scanlp
	jmp	done	
nxtdriv	lda	curdriv
	inr	a
	sta	curdriv
	cpi	10
	jz	outaher
	lda	flagd
	cpi	0
	rz
outaher	pop	hl
	jmp	done
dorest	equ	$
	lxi	d,fifcb
	mvi	c,srchf
	call	bdos
	sta	errno
	inr	a
	rz
	call	prtname
;
; loop through the next entries
;
loop	lxi	d,fifcb
	mvi	c,srchn
	call	bdos
	sta	errno
	inr	a
	rz
	call	prtname
	jmp	loop
;
; print file name in fcb 
;
; errno has the value return from find first and next 
; directory entry.
; this is an index into the dskbuffer where the file name is
; located.  there can be up to 4 records in the buffer.
;
prtname	equ	$
;
; if console active, quit
;
	mvi	c,getcos
	call	bdos
	ora	a
	jnz	done
;
	lxi	h,dskbuf  
;
; errno has the index
;
	lda	errno
	ani	3
; multiply by 32 (size of entry in buffer)
	rlc
	rlc
	rlc
	rlc
	rlc
	mvi	d,0
	mov	e,a
; and bump up to the string
	dad	d
	inx	h
	lda	curdriv
	adi	'A'
	push	psw
	lda	flagl
	cpi	0
	jnz	wfile
	pop	psw
	putc
	putc	':'
	jmp	w1file
wfile	pop	psw
	fputc	lifcb,libuf,DEFAULT
	fputc	lifcb,libuf,DEFAULT,':'
w1file	equ	$
	mvi	b,8+3
prt1	push	b
	mov	a,m
	inx	h
	push	psw
	lda	flagl
	cpi	0
	jnz	flist
	pop	psw
; write to console
	putc
	jmp	prt2
; or write to disk file
flist	equ	$
	fputc	lifcb,libuf,DEFAULT
	pop	psw
; put character on disk file
prt2	pop	b
	dcr	b
	jnz	prt1	
;
; this needs work also
;
	lda	flagl
	cpi	0
	jz	p2
	fputc	lifcb,libuf,DEFAULT,0ah
	fputc	lifcb,libuf,DEFAULT,0dh
	ret
p2	crlf
	ret
done	equ	$
	lda	flagl
	cpi	0
	jz	d1one
	if	TRACE
	lxi	h,lifcb
	call	trace
	endif
	fflush	lifcb,libuf,DEFAULT
	if	TRACE
	wto	'flushed, now close'
	endif
	close	lifcb
d1one	equ	$
	post
	fmerr
	strcpy
;	memset
	if	TRACE
trace	inx	h	
trac1	mov	a,m
	cpi	0
	rz
	putc
	inx	h
	jmp	trac1
	endif
;
; global storage
;
	prestack
filenm	ds	8+3	; space for constructing the file name
drivcnt	dw	0	; store the drive count here.
dskbuf	equ	80h
fifcb	fcb
lifcb	fcb
curdriv	db	0
diskflg	db	0	; 0 = look on current drive only.
			; 1 = search all drives on the system.
fileflg	db	0	; 0 = find a file by name
			; 1 = find files by wild card
wild	ds	32	; storage for file name, or wild card key
flagn	db	0
flagl	db	0
flagd	db	0
drivlet db	0
flagdot	db	0
libuf	ds	128
	end
